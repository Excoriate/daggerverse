// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"

	"github.com/excoriate/daggerverse/module-template/dagger/internal/dagger"
	"github.com/excoriate/daggerverse/module-template/dagger/internal/telemetry"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
	"go.opentelemetry.io/otel/trace"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = dagger.DaggerObject

type ExecError = dagger.ExecError

// The `CacheVolumeID` scalar type represents an identifier for an object of type CacheVolume.
type CacheVolumeID = dagger.CacheVolumeID

// The `ContainerID` scalar type represents an identifier for an object of type Container.
type ContainerID = dagger.ContainerID

// The `CurrentModuleID` scalar type represents an identifier for an object of type CurrentModule.
type CurrentModuleID = dagger.CurrentModuleID

// The `DirectoryID` scalar type represents an identifier for an object of type Directory.
type DirectoryID = dagger.DirectoryID

// The `EnvVariableID` scalar type represents an identifier for an object of type EnvVariable.
type EnvVariableID = dagger.EnvVariableID

// The `FieldTypeDefID` scalar type represents an identifier for an object of type FieldTypeDef.
type FieldTypeDefID = dagger.FieldTypeDefID

// The `FileID` scalar type represents an identifier for an object of type File.
type FileID = dagger.FileID

// The `FunctionArgID` scalar type represents an identifier for an object of type FunctionArg.
type FunctionArgID = dagger.FunctionArgID

// The `FunctionCallArgValueID` scalar type represents an identifier for an object of type FunctionCallArgValue.
type FunctionCallArgValueID = dagger.FunctionCallArgValueID

// The `FunctionCallID` scalar type represents an identifier for an object of type FunctionCall.
type FunctionCallID = dagger.FunctionCallID

// The `FunctionID` scalar type represents an identifier for an object of type Function.
type FunctionID = dagger.FunctionID

// The `GeneratedCodeID` scalar type represents an identifier for an object of type GeneratedCode.
type GeneratedCodeID = dagger.GeneratedCodeID

// The `GitModuleSourceID` scalar type represents an identifier for an object of type GitModuleSource.
type GitModuleSourceID = dagger.GitModuleSourceID

// The `GitRefID` scalar type represents an identifier for an object of type GitRef.
type GitRefID = dagger.GitRefID

// The `GitRepositoryID` scalar type represents an identifier for an object of type GitRepository.
type GitRepositoryID = dagger.GitRepositoryID

// The `InputTypeDefID` scalar type represents an identifier for an object of type InputTypeDef.
type InputTypeDefID = dagger.InputTypeDefID

// The `InterfaceTypeDefID` scalar type represents an identifier for an object of type InterfaceTypeDef.
type InterfaceTypeDefID = dagger.InterfaceTypeDefID

// An arbitrary JSON-encoded value.
type JSON = dagger.JSON

// The `LabelID` scalar type represents an identifier for an object of type Label.
type LabelID = dagger.LabelID

// The `ListTypeDefID` scalar type represents an identifier for an object of type ListTypeDef.
type ListTypeDefID = dagger.ListTypeDefID

// The `LocalModuleSourceID` scalar type represents an identifier for an object of type LocalModuleSource.
type LocalModuleSourceID = dagger.LocalModuleSourceID

// The `ModuleDependencyID` scalar type represents an identifier for an object of type ModuleDependency.
type ModuleDependencyID = dagger.ModuleDependencyID

// The `ModuleID` scalar type represents an identifier for an object of type Module.
type ModuleID = dagger.ModuleID

// The `ModuleSourceID` scalar type represents an identifier for an object of type ModuleSource.
type ModuleSourceID = dagger.ModuleSourceID

// The `ModuleSourceViewID` scalar type represents an identifier for an object of type ModuleSourceView.
type ModuleSourceViewID = dagger.ModuleSourceViewID

// The `ObjectTypeDefID` scalar type represents an identifier for an object of type ObjectTypeDef.
type ObjectTypeDefID = dagger.ObjectTypeDefID

// The platform config OS and architecture in a Container.
//
// The format is [os]/[platform]/[version] (e.g., "darwin/arm64/v7", "windows/amd64", "linux/arm64").
type Platform = dagger.Platform

// The `PortID` scalar type represents an identifier for an object of type Port.
type PortID = dagger.PortID

// The `ScalarTypeDefID` scalar type represents an identifier for an object of type ScalarTypeDef.
type ScalarTypeDefID = dagger.ScalarTypeDefID

// The `SecretID` scalar type represents an identifier for an object of type Secret.
type SecretID = dagger.SecretID

// The `ServiceID` scalar type represents an identifier for an object of type Service.
type ServiceID = dagger.ServiceID

// The `SocketID` scalar type represents an identifier for an object of type Socket.
type SocketID = dagger.SocketID

// The `TerminalID` scalar type represents an identifier for an object of type Terminal.
type TerminalID = dagger.TerminalID

// The `TypeDefID` scalar type represents an identifier for an object of type TypeDef.
type TypeDefID = dagger.TypeDefID

// The absence of a value.
//
// A Null Void is used as a placeholder for resolvers that do not return anything.
type Void = dagger.Void

// Key value object that represents a build argument.
type BuildArg = dagger.BuildArg

// Key value object that represents a pipeline label.
type PipelineLabel = dagger.PipelineLabel

// Port forwarding rules for tunneling network traffic.
type PortForward = dagger.PortForward

// A directory whose contents persist across runs.
type CacheVolume = dagger.CacheVolume

// An OCI-compatible container, also known as a Docker container.
type Container = dagger.Container

type WithContainerFunc = dagger.WithContainerFunc

// ContainerAsTarballOpts contains options for Container.AsTarball
type ContainerAsTarballOpts = dagger.ContainerAsTarballOpts

// ContainerBuildOpts contains options for Container.Build
type ContainerBuildOpts = dagger.ContainerBuildOpts

// ContainerExportOpts contains options for Container.Export
type ContainerExportOpts = dagger.ContainerExportOpts

// ContainerImportOpts contains options for Container.Import
type ContainerImportOpts = dagger.ContainerImportOpts

// ContainerPipelineOpts contains options for Container.Pipeline
type ContainerPipelineOpts = dagger.ContainerPipelineOpts

// ContainerPublishOpts contains options for Container.Publish
type ContainerPublishOpts = dagger.ContainerPublishOpts

// ContainerTerminalOpts contains options for Container.Terminal
type ContainerTerminalOpts = dagger.ContainerTerminalOpts

// ContainerWithDefaultTerminalCmdOpts contains options for Container.WithDefaultTerminalCmd
type ContainerWithDefaultTerminalCmdOpts = dagger.ContainerWithDefaultTerminalCmdOpts

// ContainerWithDirectoryOpts contains options for Container.WithDirectory
type ContainerWithDirectoryOpts = dagger.ContainerWithDirectoryOpts

// ContainerWithEntrypointOpts contains options for Container.WithEntrypoint
type ContainerWithEntrypointOpts = dagger.ContainerWithEntrypointOpts

// ContainerWithEnvVariableOpts contains options for Container.WithEnvVariable
type ContainerWithEnvVariableOpts = dagger.ContainerWithEnvVariableOpts

// ContainerWithExecOpts contains options for Container.WithExec
type ContainerWithExecOpts = dagger.ContainerWithExecOpts

// ContainerWithExposedPortOpts contains options for Container.WithExposedPort
type ContainerWithExposedPortOpts = dagger.ContainerWithExposedPortOpts

// ContainerWithFileOpts contains options for Container.WithFile
type ContainerWithFileOpts = dagger.ContainerWithFileOpts

// ContainerWithFilesOpts contains options for Container.WithFiles
type ContainerWithFilesOpts = dagger.ContainerWithFilesOpts

// ContainerWithMountedCacheOpts contains options for Container.WithMountedCache
type ContainerWithMountedCacheOpts = dagger.ContainerWithMountedCacheOpts

// ContainerWithMountedDirectoryOpts contains options for Container.WithMountedDirectory
type ContainerWithMountedDirectoryOpts = dagger.ContainerWithMountedDirectoryOpts

// ContainerWithMountedFileOpts contains options for Container.WithMountedFile
type ContainerWithMountedFileOpts = dagger.ContainerWithMountedFileOpts

// ContainerWithMountedSecretOpts contains options for Container.WithMountedSecret
type ContainerWithMountedSecretOpts = dagger.ContainerWithMountedSecretOpts

// ContainerWithNewFileOpts contains options for Container.WithNewFile
type ContainerWithNewFileOpts = dagger.ContainerWithNewFileOpts

// ContainerWithUnixSocketOpts contains options for Container.WithUnixSocket
type ContainerWithUnixSocketOpts = dagger.ContainerWithUnixSocketOpts

// ContainerWithoutEntrypointOpts contains options for Container.WithoutEntrypoint
type ContainerWithoutEntrypointOpts = dagger.ContainerWithoutEntrypointOpts

// ContainerWithoutExposedPortOpts contains options for Container.WithoutExposedPort
type ContainerWithoutExposedPortOpts = dagger.ContainerWithoutExposedPortOpts

// Reflective module API provided to functions at runtime.
type CurrentModule = dagger.CurrentModule

// CurrentModuleWorkdirOpts contains options for CurrentModule.Workdir
type CurrentModuleWorkdirOpts = dagger.CurrentModuleWorkdirOpts

// A directory.
type Directory = dagger.Directory

type WithDirectoryFunc = dagger.WithDirectoryFunc

// DirectoryAsModuleOpts contains options for Directory.AsModule
type DirectoryAsModuleOpts = dagger.DirectoryAsModuleOpts

// DirectoryDockerBuildOpts contains options for Directory.DockerBuild
type DirectoryDockerBuildOpts = dagger.DirectoryDockerBuildOpts

// DirectoryEntriesOpts contains options for Directory.Entries
type DirectoryEntriesOpts = dagger.DirectoryEntriesOpts

// DirectoryExportOpts contains options for Directory.Export
type DirectoryExportOpts = dagger.DirectoryExportOpts

// DirectoryPipelineOpts contains options for Directory.Pipeline
type DirectoryPipelineOpts = dagger.DirectoryPipelineOpts

// DirectoryWithDirectoryOpts contains options for Directory.WithDirectory
type DirectoryWithDirectoryOpts = dagger.DirectoryWithDirectoryOpts

// DirectoryWithFileOpts contains options for Directory.WithFile
type DirectoryWithFileOpts = dagger.DirectoryWithFileOpts

// DirectoryWithFilesOpts contains options for Directory.WithFiles
type DirectoryWithFilesOpts = dagger.DirectoryWithFilesOpts

// DirectoryWithNewDirectoryOpts contains options for Directory.WithNewDirectory
type DirectoryWithNewDirectoryOpts = dagger.DirectoryWithNewDirectoryOpts

// DirectoryWithNewFileOpts contains options for Directory.WithNewFile
type DirectoryWithNewFileOpts = dagger.DirectoryWithNewFileOpts

// An environment variable name and value.
type EnvVariable = dagger.EnvVariable

// A definition of a field on a custom object defined in a Module.
//
// A field on an object has a static value, as opposed to a function on an object whose value is computed by invoking code (and can accept arguments).
type FieldTypeDef = dagger.FieldTypeDef

// A file.
type File = dagger.File

type WithFileFunc = dagger.WithFileFunc

// FileExportOpts contains options for File.Export
type FileExportOpts = dagger.FileExportOpts

// Function represents a resolver provided by a Module.
//
// A function always evaluates against a parent object and is given a set of named arguments.
type Function = dagger.Function

type WithFunctionFunc = dagger.WithFunctionFunc

// FunctionWithArgOpts contains options for Function.WithArg
type FunctionWithArgOpts = dagger.FunctionWithArgOpts

// An argument accepted by a function.
//
// This is a specification for an argument at function definition time, not an argument passed at function call time.
type FunctionArg = dagger.FunctionArg

// An active function call.
type FunctionCall = dagger.FunctionCall

// A value passed as a named argument to a function call.
type FunctionCallArgValue = dagger.FunctionCallArgValue

// The result of running an SDK's codegen.
type GeneratedCode = dagger.GeneratedCode

type WithGeneratedCodeFunc = dagger.WithGeneratedCodeFunc

// Module source originating from a git repo.
type GitModuleSource = dagger.GitModuleSource

// A git ref (tag, branch, or commit).
type GitRef = dagger.GitRef

// GitRefTreeOpts contains options for GitRef.Tree
type GitRefTreeOpts = dagger.GitRefTreeOpts

// A git repository.
type GitRepository = dagger.GitRepository

type WithGitRepositoryFunc = dagger.WithGitRepositoryFunc

// A graphql input type, which is essentially just a group of named args.
// This is currently only used to represent pre-existing usage of graphql input types
// in the core API. It is not used by user modules and shouldn't ever be as user
// module accept input objects via their id rather than graphql input types.
type InputTypeDef = dagger.InputTypeDef

// A definition of a custom interface defined in a Module.
type InterfaceTypeDef = dagger.InterfaceTypeDef

// A simple key value object that represents a label.
type Label = dagger.Label

// A definition of a list type in a Module.
type ListTypeDef = dagger.ListTypeDef

// Module source that that originates from a path locally relative to an arbitrary directory.
type LocalModuleSource = dagger.LocalModuleSource

// A Dagger module.
type Module = dagger.Module

type WithModuleFunc = dagger.WithModuleFunc

// The configuration of dependency of a module.
type ModuleDependency = dagger.ModuleDependency

// The source needed to load and run a module, along with any metadata about the source such as versions/urls/etc.
type ModuleSource = dagger.ModuleSource

type WithModuleSourceFunc = dagger.WithModuleSourceFunc

// ModuleSourceResolveDirectoryFromCallerOpts contains options for ModuleSource.ResolveDirectoryFromCaller
type ModuleSourceResolveDirectoryFromCallerOpts = dagger.ModuleSourceResolveDirectoryFromCallerOpts

// A named set of path filters that can be applied to directory arguments provided to functions.
type ModuleSourceView = dagger.ModuleSourceView

// A definition of a custom object defined in a Module.
type ObjectTypeDef = dagger.ObjectTypeDef

// A port exposed by a container.
type Port = dagger.Port

// The root of the DAG.
type Client = dagger.Client

type WithClientFunc = dagger.WithClientFunc

// ContainerOpts contains options for Client.Container
type ContainerOpts = dagger.ContainerOpts

// DirectoryOpts contains options for Client.Directory
type DirectoryOpts = dagger.DirectoryOpts

// GitOpts contains options for Client.Git
type GitOpts = dagger.GitOpts

// HTTPOpts contains options for Client.HTTP
type HTTPOpts = dagger.HTTPOpts

// ModuleDependencyOpts contains options for Client.ModuleDependency
type ModuleDependencyOpts = dagger.ModuleDependencyOpts

// ModuleSourceOpts contains options for Client.ModuleSource
type ModuleSourceOpts = dagger.ModuleSourceOpts

// PipelineOpts contains options for Client.Pipeline
type PipelineOpts = dagger.PipelineOpts

// SecretOpts contains options for Client.Secret
type SecretOpts = dagger.SecretOpts

// A definition of a custom scalar defined in a Module.
type ScalarTypeDef = dagger.ScalarTypeDef

// A reference to a secret value, which can be handled more safely than the value itself.
type Secret = dagger.Secret

// A content-addressed service providing TCP connectivity.
type Service = dagger.Service

// ServiceEndpointOpts contains options for Service.Endpoint
type ServiceEndpointOpts = dagger.ServiceEndpointOpts

// ServiceStopOpts contains options for Service.Stop
type ServiceStopOpts = dagger.ServiceStopOpts

// ServiceUpOpts contains options for Service.Up
type ServiceUpOpts = dagger.ServiceUpOpts

// A Unix or TCP/IP socket that can be mounted into a container.
type Socket = dagger.Socket

// An interactive terminal that clients can connect to.
type Terminal = dagger.Terminal

// A definition of a parameter or return type in a Module.
type TypeDef = dagger.TypeDef

type WithTypeDefFunc = dagger.WithTypeDefFunc

// TypeDefWithFieldOpts contains options for TypeDef.WithField
type TypeDefWithFieldOpts = dagger.TypeDefWithFieldOpts

// TypeDefWithInterfaceOpts contains options for TypeDef.WithInterface
type TypeDefWithInterfaceOpts = dagger.TypeDefWithInterfaceOpts

// TypeDefWithObjectOpts contains options for TypeDef.WithObject
type TypeDefWithObjectOpts = dagger.TypeDefWithObjectOpts

// TypeDefWithScalarOpts contains options for TypeDef.WithScalar
type TypeDefWithScalarOpts = dagger.TypeDefWithScalarOpts

// Sharing mode of the cache volume.
type CacheSharingMode = dagger.CacheSharingMode

const (
	// Shares the cache volume amongst many build pipelines, but will serialize the writes
	Locked CacheSharingMode = dagger.Locked

	// Keeps a cache volume for a single build pipeline
	Private CacheSharingMode = dagger.Private

	// Shares the cache volume amongst many build pipelines
	Shared CacheSharingMode = dagger.Shared
)

// Compression algorithm to use for image layers.
type ImageLayerCompression = dagger.ImageLayerCompression

const (
	Estargz ImageLayerCompression = dagger.Estargz

	Gzip ImageLayerCompression = dagger.Gzip

	Uncompressed ImageLayerCompression = dagger.Uncompressed

	Zstd ImageLayerCompression = dagger.Zstd
)

// Mediatypes to use in published or exported image metadata.
type ImageMediaTypes = dagger.ImageMediaTypes

const (
	Dockermediatypes ImageMediaTypes = dagger.Dockermediatypes

	Ocimediatypes ImageMediaTypes = dagger.Ocimediatypes
)

// The kind of module source.
type ModuleSourceKind = dagger.ModuleSourceKind

const (
	GitSource ModuleSourceKind = dagger.GitSource

	LocalSource ModuleSourceKind = dagger.LocalSource
)

// Transport layer network protocol associated to a port.
type NetworkProtocol = dagger.NetworkProtocol

const (
	Tcp NetworkProtocol = dagger.Tcp

	Udp NetworkProtocol = dagger.Udp
)

// Distinguishes the different kinds of TypeDefs.
type TypeDefKind = dagger.TypeDefKind

const (
	// A boolean value.
	BooleanKind TypeDefKind = dagger.BooleanKind

	// A graphql input type, used only when representing the core API via TypeDefs.
	InputKind TypeDefKind = dagger.InputKind

	// An integer value.
	IntegerKind TypeDefKind = dagger.IntegerKind

	// A named type of functions that can be matched+implemented by other objects+interfaces.
	//
	// Always paired with an InterfaceTypeDef.
	InterfaceKind TypeDefKind = dagger.InterfaceKind

	// A list of values all having the same type.
	//
	// Always paired with a ListTypeDef.
	ListKind TypeDefKind = dagger.ListKind

	// A named type defined in the GraphQL schema, with fields and functions.
	//
	// Always paired with an ObjectTypeDef.
	ObjectKind TypeDefKind = dagger.ObjectKind

	// A scalar value of any basic kind.
	ScalarKind TypeDefKind = dagger.ScalarKind

	// A string value.
	StringKind TypeDefKind = dagger.StringKind

	// A special kind used to signify that no value is returned.
	//
	// This is used for functions that have no return value. The outer TypeDef specifying this Kind is always Optional, as the Void is never actually represented.
	VoidKind TypeDefKind = dagger.VoidKind
)

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r ModuleTemplate) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Ctr *Container
	}
	concrete.Ctr = r.Ctr
	return json.Marshal(&concrete)
}

func (r *ModuleTemplate) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Ctr *Container
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Ctr = concrete.Ctr
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
}

func dispatch(ctx context.Context) error {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return fmt.Errorf("invoke: %w", err)
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}
	_, err = fnCall.ReturnValue(ctx, JSON(resultBytes))
	if err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}

func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	switch parentName {
	case "ModuleTemplate":
		switch fnName {
		case "Base":
			var parent ModuleTemplate
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var imageUrl string
			if inputArgs["imageURL"] != nil {
				err = json.Unmarshal([]byte(inputArgs["imageURL"]), &imageUrl)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg imageURL", err))
				}
			}
			return (*ModuleTemplate).Base(&parent, imageUrl), nil
		case "Terminal":
			var parent ModuleTemplate
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*ModuleTemplate).Terminal(&parent), nil
		case "RunShell":
			var parent ModuleTemplate
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var cmd string
			if inputArgs["cmd"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cmd"]), &cmd)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cmd", err))
				}
			}
			return (*ModuleTemplate).RunShell(&parent, cmd)
		case "WithEnvironmentVariable":
			var parent ModuleTemplate
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			var value string
			if inputArgs["value"] != nil {
				err = json.Unmarshal([]byte(inputArgs["value"]), &value)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg value", err))
				}
			}
			var expand bool
			if inputArgs["expand"] != nil {
				err = json.Unmarshal([]byte(inputArgs["expand"]), &expand)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg expand", err))
				}
			}
			return (*ModuleTemplate).WithEnvironmentVariable(&parent, name, value, expand), nil
		case "WithSource":
			var parent ModuleTemplate
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var src *Directory
			if inputArgs["src"] != nil {
				err = json.Unmarshal([]byte(inputArgs["src"]), &src)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg src", err))
				}
			}
			var workdir string
			if inputArgs["workdir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["workdir"]), &workdir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg workdir", err))
				}
			}
			return (*ModuleTemplate).WithSource(&parent, src, workdir), nil
		case "WithContainer":
			var parent ModuleTemplate
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ctr *Container
			if inputArgs["ctr"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ctr"]), &ctr)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ctr", err))
				}
			}
			return (*ModuleTemplate).WithContainer(&parent, ctr), nil
		case "WithDockerService":
			var parent ModuleTemplate
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var dockerVersion string
			if inputArgs["dockerVersion"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dockerVersion"]), &dockerVersion)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dockerVersion", err))
				}
			}
			return (*ModuleTemplate).WithDockerService(&parent, dockerVersion), nil
		case "WithFileMountedInContainer":
			var parent ModuleTemplate
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var file *File
			if inputArgs["file"] != nil {
				err = json.Unmarshal([]byte(inputArgs["file"]), &file)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg file", err))
				}
			}
			var dest string
			if inputArgs["dest"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dest"]), &dest)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dest", err))
				}
			}
			var owner string
			if inputArgs["owner"] != nil {
				err = json.Unmarshal([]byte(inputArgs["owner"]), &owner)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg owner", err))
				}
			}
			return (*ModuleTemplate).WithFileMountedInContainer(&parent, file, dest, owner), nil
		case "":
			var parent ModuleTemplate
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			var image string
			if inputArgs["image"] != nil {
				err = json.Unmarshal([]byte(inputArgs["image"]), &image)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg image", err))
				}
			}
			var ctr *Container
			if inputArgs["ctr"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ctr"]), &ctr)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ctr", err))
				}
			}
			var envVarsFromHost []string
			if inputArgs["envVarsFromHost"] != nil {
				err = json.Unmarshal([]byte(inputArgs["envVarsFromHost"]), &envVarsFromHost)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg envVarsFromHost", err))
				}
			}
			return New(version, image, ctr, envVarsFromHost)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "":
		return dag.Module().
			WithDescription("Package main provides the ModuleTemplate Dagger module and related functions.\n\nThis module has been generated via dagger init and serves as a reference to\nbasic module structure as you get started with Dagger. The module demonstrates\nusage of arguments and return types using simple echo and grep commands. The functions\ncan be called from the dagger CLI or from one of the SDKs.\n\nThe first line in this comment block is a short description line and the\nrest is a long description with more detail on the module's purpose or usage,\nif appropriate. All modules should have a short description.\n").
			WithObject(
				dag.TypeDef().WithObject("ModuleTemplate", TypeDefWithObjectOpts{Description: "ModuleTemplate is a Dagger module.\n\nThis module is used to create and manage containers."}).
					WithFunction(
						dag.Function("Base",
							dag.TypeDef().WithObject("ModuleTemplate")).
							WithDescription("Base sets the base image and version, and creates the base container.\n\nThe default image is \"alpine/latest\" and the default version is \"latest\".").
							WithArg("imageURL", dag.TypeDef().WithKind(StringKind))).
					WithFunction(
						dag.Function("Terminal",
							dag.TypeDef().WithObject("Terminal")).
							WithDescription("Terminal returns a terminal\n\nIt returns a terminal for the container.\nArguments:\n- None.\nReturns:\n- *Terminal: The terminal for the container.")).
					WithFunction(
						dag.Function("RunShell",
							dag.TypeDef().WithKind(StringKind)).
							WithDescription("RunShell runs a shell command in the container.\n\nIt runs a shell command in the container and returns the output.\nArguments:\n- cmd: The command to run in the container.\nReturns:\n- string: The output of the command.\n- error: An error if the command fails.").
							WithArg("cmd", dag.TypeDef().WithKind(StringKind))).
					WithFunction(
						dag.Function("WithEnvironmentVariable",
							dag.TypeDef().WithObject("ModuleTemplate")).
							WithDescription("WithEnvironmentVariable sets an environment variable in the container.\n\nParameters:\n  - name: The name of the environment variable (e.g., \"HOST\").\n  - value: The value of the environment variable (e.g., \"localhost\").\n  - expand: Whether to replace `${VAR}` or $VAR in the value according to the current\n    environment variables defined in the container (e.g., \"/opt/bin:$PATH\").\n    Optional parameter.").
							WithArg("name", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "name is the name of the environment variable."}).
							WithArg("value", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "value is the value of the environment variable."}).
							WithArg("expand", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "expand is whether to replace `${VAR}` or $VAR in the value according to the current"})).
					WithFunction(
						dag.Function("WithSource",
							dag.TypeDef().WithObject("ModuleTemplate")).
							WithDescription("WithSource sets the source directory for the container.\n\nParameters:\n- src: The directory that contains all the source code, including the module directory.\n- workdir: The working directory within the container. Optional parameter.").
							WithArg("src", dag.TypeDef().WithObject("Directory"), FunctionWithArgOpts{Description: "src is the directory that contains all the source code, including the module directory."}).
							WithArg("workdir", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "workdir is the working directory within the container. If not set it'll default to /mnt"})).
					WithFunction(
						dag.Function("WithContainer",
							dag.TypeDef().WithObject("ModuleTemplate")).
							WithDescription("WithContainer sets the container to be used.\n\nParameters:\n- ctr: The container to run the command in. If passed, it will override the container set in the Dagger instance.").
							WithArg("ctr", dag.TypeDef().WithObject("Container"))).
					WithFunction(
						dag.Function("WithDockerService",
							dag.TypeDef().WithObject("Service")).
							WithDescription("WithDockerService sets up the container with the Docker service.\n\nIt sets up the container with the Docker service.\nParameters:\n  - dockerVersion: The version of the Docker engine to use, e.g., \"v20.10.17\".\n    Optional parameter. If not provided, a default version is used.").
							WithArg("dockerVersion", dag.TypeDef().WithKind(StringKind))).
					WithFunction(
						dag.Function("WithFileMountedInContainer",
							dag.TypeDef().WithObject("ModuleTemplate")).
							WithDescription("WithFileMountedInContainer adds a file to the container.\n\nParameters:\n- file: The file to add to the container.\n- dest: The destination path in the container. Optional parameter.\n- owner: The owner of the file. Optional parameter.").
							WithArg("file", dag.TypeDef().WithObject("File")).
							WithArg("dest", dag.TypeDef().WithKind(StringKind)).
							WithArg("owner", dag.TypeDef().WithKind(StringKind))).
					WithField("Ctr", dag.TypeDef().WithObject("Container"), TypeDefWithFieldOpts{Description: "Ctr is the container to use as a base container."}).
					WithConstructor(
						dag.Function("New",
							dag.TypeDef().WithObject("ModuleTemplate")).
							WithDescription("New creates a new ModuleTemplate module.\n\nParameters:\n- version: The version of the GoReleaser to use, e.g., \"v1.22.0\". Optional parameter.\n- image: The image to use as the base container. Optional parameter.\n- ctr: The container to use as a base container. Optional parameter.\n- envVarsFromHost: A list of environment variables to pass from the host to the container in a\nslice of strings. Optional parameter.\n\nReturns a pointer to a ModuleTemplate instance and an error, if any.").
							WithArg("version", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "version is the version of the container image to use."}).
							WithArg("image", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "image is the container image to use."}).
							WithArg("ctr", dag.TypeDef().WithObject("Container").WithOptional(true), FunctionWithArgOpts{Description: "ctr is the container to use as a base container."}).
							WithArg("envVarsFromHost", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "envVarsFromHost is a list of environment variables to pass from the host to the container in a slice of strings."}))), nil
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
