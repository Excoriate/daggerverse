// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
	"go.opentelemetry.io/otel/trace"

	"Terratest/internal/dagger"
	"Terratest/internal/querybuilder"
	"Terratest/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Terratest) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Version   string
		TfVersion string
		Image     string
		Ctr       *any
	}
	concrete.Version = r.Version
	concrete.TfVersion = r.TfVersion
	concrete.Image = r.Image
	concrete.Ctr = r.Ctr
	return json.Marshal(&concrete)
}

func (r *Terratest) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Version   string
		TfVersion string
		Image     string
		Ctr       *any
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Version = concrete.Version
	r.TfVersion = concrete.TfVersion
	r.Image = concrete.Image
	r.Ctr = concrete.Ctr
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
}

func dispatch(ctx context.Context) error {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return fmt.Errorf("invoke: %w", err)
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}
	if err = fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Terratest":
		switch fnName {
		case "WithSource":
			var parent Terratest
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var src *any
			if inputArgs["src"] != nil {
				err = json.Unmarshal([]byte(inputArgs["src"]), &src)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg src", err))
				}
			}
			var workdir string
			if inputArgs["workdir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["workdir"]), &workdir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg workdir", err))
				}
			}
			return (*Terratest).WithSource(&parent, src, workdir), nil
		case "WithCgoDisabled":
			var parent Terratest
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Terratest).WithCgoDisabled(&parent), nil
		case "WithEnvVar":
			var parent Terratest
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			var value string
			if inputArgs["value"] != nil {
				err = json.Unmarshal([]byte(inputArgs["value"]), &value)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg value", err))
				}
			}
			var expand bool
			if inputArgs["expand"] != nil {
				err = json.Unmarshal([]byte(inputArgs["expand"]), &expand)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg expand", err))
				}
			}
			return (*Terratest).WithEnvVar(&parent, name, value, expand), nil
		case "Base":
			var parent Terratest
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var goVersion string
			if inputArgs["goVersion"] != nil {
				err = json.Unmarshal([]byte(inputArgs["goVersion"]), &goVersion)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg goVersion", err))
				}
			}
			var tfVersion string
			if inputArgs["tfVersion"] != nil {
				err = json.Unmarshal([]byte(inputArgs["tfVersion"]), &tfVersion)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg tfVersion", err))
				}
			}
			return (*Terratest).Base(&parent, goVersion, tfVersion), nil
		case "WithContainer":
			var parent Terratest
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ctr *any
			if inputArgs["ctr"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ctr"]), &ctr)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ctr", err))
				}
			}
			return (*Terratest).WithContainer(&parent, ctr), nil
		case "Run":
			var parent Terratest
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var testDir *any
			if inputArgs["testDir"] != nil {
				err = json.Unmarshal([]byte(inputArgs["testDir"]), &testDir)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg testDir", err))
				}
			}
			var args string
			if inputArgs["args"] != nil {
				err = json.Unmarshal([]byte(inputArgs["args"]), &args)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg args", err))
				}
			}
			return (*Terratest).Run(&parent, testDir, args)
		case "":
			var parent Terratest
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			var tfVersion string
			if inputArgs["tfVersion"] != nil {
				err = json.Unmarshal([]byte(inputArgs["tfVersion"]), &tfVersion)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg tfVersion", err))
				}
			}
			var image string
			if inputArgs["image"] != nil {
				err = json.Unmarshal([]byte(inputArgs["image"]), &image)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg image", err))
				}
			}
			var ctr *any
			if inputArgs["ctr"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ctr"]), &ctr)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ctr", err))
				}
			}
			var envVars string
			if inputArgs["envVars"] != nil {
				err = json.Unmarshal([]byte(inputArgs["envVars"]), &envVars)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg envVars", err))
				}
			}
			return New(version, tfVersion, image, ctr, envVars), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "":
		return dag.Module().
			WithObject(
				dag.TypeDef().WithObject("Terratest").
					WithFunction(
						dag.Function("WithSource",
							dag.TypeDef().WithObject("Terratest")).
							WithDescription("WithSource Set the source directory.").
							WithArg("src", dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "Src is the directory that contains all the source code, including the module directory."}).
							WithArg("workdir", dag.TypeDef().WithKind(dagger.StringKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "workdir is the working directory."})).
					WithFunction(
						dag.Function("WithCgoDisabled",
							dag.TypeDef().WithObject("Terratest")).
							WithDescription("WithCgoDisabled Set CGO_ENABLED environment variable to 0.")).
					WithFunction(
						dag.Function("WithEnvVar",
							dag.TypeDef().WithObject("Terratest")).
							WithDescription("WithEnvVar Set an environment variable.").
							WithArg("name", dag.TypeDef().WithKind(dagger.StringKind), dagger.FunctionWithArgOpts{Description: "The name of the environment variable (e.g., \"HOST\")."}).
							WithArg("value", dag.TypeDef().WithKind(dagger.StringKind), dagger.FunctionWithArgOpts{Description: "The value of the environment variable (e.g., \"localhost\")."}).
							WithArg("expand", dag.TypeDef().WithKind(dagger.BooleanKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "Replace `${VAR}` or $VAR in the value according to the current environment\nvariables defined in the container (e.g., \"/opt/bin:$PATH\")."})).
					WithFunction(
						dag.Function("Base",
							dag.TypeDef().WithObject("Terratest")).
							WithDescription("Base sets up the Container with a golang image and cache volumes\nversion string").
							WithArg("goVersion", dag.TypeDef().WithKind(dagger.StringKind)).
							WithArg("tfVersion", dag.TypeDef().WithKind(dagger.StringKind))).
					WithFunction(
						dag.Function("WithContainer",
							dag.TypeDef().WithObject("Terratest")).
							WithDescription("WithContainer specifies the container to use in the Terraform module.").
							WithArg("ctr", dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true))).
					WithFunction(
						dag.Function("Run",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithArg("testDir", dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "testDir is the directory that contains all the test code."}).
							WithArg("args", dag.TypeDef().WithKind(dagger.StringKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "args is the arguments to pass to the 'go test' command."})).
					WithField("Version", dag.TypeDef().WithKind(dagger.StringKind), dagger.TypeDefWithFieldOpts{Description: "The Version of the Golang image that'll host the 'terratest' test"}).
					WithField("TfVersion", dag.TypeDef().WithKind(dagger.StringKind), dagger.TypeDefWithFieldOpts{Description: "TfVersion is the Version of the Terraform to use, e.g., \"0.12.24\".\nby default, it uses the latest Version."}).
					WithField("Image", dag.TypeDef().WithKind(dagger.StringKind), dagger.TypeDefWithFieldOpts{Description: "Image of the container to use."}).
					WithField("Ctr", dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true), dagger.TypeDefWithFieldOpts{Description: "Ctr is the container to use as a base container."}).
					WithConstructor(
						dag.Function("New",
							dag.TypeDef().WithObject("Terratest")).
							WithArg("version", dag.TypeDef().WithKind(dagger.StringKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "the Version of the Terraform to use, e.g., \"0.12.24\".\nby default, it uses the latest Version.", DefaultValue: dagger.JSON("\"1.22.0-alpine3.19\"")}).
							WithArg("tfVersion", dag.TypeDef().WithKind(dagger.StringKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "the Version of the Terraform to use, e.g., \"0.12.24\".\nby default, it uses the latest Version.", DefaultValue: dagger.JSON("\"1.6.0\"")}).
							WithArg("image", dag.TypeDef().WithKind(dagger.StringKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "Image of the container to use.\nby default, it uses the official HashiCorp Terraform Image hashicorp/terraform.", DefaultValue: dagger.JSON("\"gcr.io/distroless/static-debian11\"")}).
							WithArg("ctr", dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "ctr is the container to use as a base container.\nIt's an optional parameter. If it's not set, it's going to create a new container."}).
							WithArg("envVars", dag.TypeDef().WithKind(dagger.StringKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "envVars is a string of environment variables in the form of \"key1=value1,key2=value2\""}))), nil
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
