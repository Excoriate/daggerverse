// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/Excoriate/daggerverse/registryauth/internal/dagger"
	"github.com/Excoriate/daggerverse/registryauth/internal/querybuilder"
	"github.com/Excoriate/daggerverse/registryauth/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Registryauth) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Ctr *dagger.Container
	}
	concrete.Ctr = r.Ctr
	return json.Marshal(&concrete)
}

func (r *Registryauth) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Ctr *dagger.Container
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Ctr = concrete.Ctr
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
}

func dispatch(ctx context.Context) error {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return fmt.Errorf("invoke: %w", err)
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}
	if err = fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Registryauth":
		switch fnName {
		case "Base":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var imageUrl string
			if inputArgs["imageURL"] != nil {
				err = json.Unmarshal([]byte(inputArgs["imageURL"]), &imageUrl)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg imageURL", err))
				}
			}
			return (*Registryauth).Base(&parent, imageUrl), nil
		case "WithEnvironmentVariable":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			var value string
			if inputArgs["value"] != nil {
				err = json.Unmarshal([]byte(inputArgs["value"]), &value)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg value", err))
				}
			}
			var expand bool
			if inputArgs["expand"] != nil {
				err = json.Unmarshal([]byte(inputArgs["expand"]), &expand)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg expand", err))
				}
			}
			return (*Registryauth).WithEnvironmentVariable(&parent, name, value, expand), nil
		case "WithContainer":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ctr *dagger.Container
			if inputArgs["ctr"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ctr"]), &ctr)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ctr", err))
				}
			}
			return (*Registryauth).WithContainer(&parent, ctr), nil
		case "WithFileMountedInContainer":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var file *dagger.File
			if inputArgs["file"] != nil {
				err = json.Unmarshal([]byte(inputArgs["file"]), &file)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg file", err))
				}
			}
			var dest string
			if inputArgs["dest"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dest"]), &dest)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dest", err))
				}
			}
			var owner string
			if inputArgs["owner"] != nil {
				err = json.Unmarshal([]byte(inputArgs["owner"]), &owner)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg owner", err))
				}
			}
			return (*Registryauth).WithFileMountedInContainer(&parent, file, dest, owner), nil
		case "WithCacheBuster":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Registryauth).WithCacheBuster(&parent), nil
		case "OpenTerminal":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Registryauth).OpenTerminal(&parent), nil
		case "RunShell":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var cmd string
			if inputArgs["cmd"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cmd"]), &cmd)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cmd", err))
				}
			}
			return (*Registryauth).RunShell(&parent, cmd)
		case "PrintEnvVars":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Registryauth).PrintEnvVars(&parent)
		case "BaseAlpine":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			return (*Registryauth).BaseAlpine(&parent, version), nil
		case "BaseUbuntu":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			return (*Registryauth).BaseUbuntu(&parent, version), nil
		case "BaseBusyBox":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			return (*Registryauth).BaseBusyBox(&parent, version), nil
		case "BaseWolfi":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			var packages []string
			if inputArgs["packages"] != nil {
				err = json.Unmarshal([]byte(inputArgs["packages"]), &packages)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg packages", err))
				}
			}
			var overlays []*dagger.Container
			if inputArgs["overlays"] != nil {
				err = json.Unmarshal([]byte(inputArgs["overlays"]), &overlays)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg overlays", err))
				}
			}
			return (*Registryauth).BaseWolfi(&parent, version, packages, overlays), nil
		case "":
			var parent Registryauth
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			var image string
			if inputArgs["image"] != nil {
				err = json.Unmarshal([]byte(inputArgs["image"]), &image)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg image", err))
				}
			}
			var ctr *dagger.Container
			if inputArgs["ctr"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ctr"]), &ctr)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ctr", err))
				}
			}
			var envVarsFromHost []string
			if inputArgs["envVarsFromHost"] != nil {
				err = json.Unmarshal([]byte(inputArgs["envVarsFromHost"]), &envVarsFromHost)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg envVarsFromHost", err))
				}
			}
			return New(version, image, ctr, envVarsFromHost)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "":
		return dag.Module().
			WithDescription("Package main provides the Registryauth Dagger module and related functions.\n\nThis module has been generated via dagger init and serves as a reference to\nbasic module structure as you get started with Dagger. The module demonstrates\nusage of arguments and return types using simple echo and grep commands. The functions\ncan be called from the dagger CLI or from one of the SDKs.\n\nThe first line in this comment block is a short description line and the\nrest is a long description with more detail on the module's purpose or usage,\nif appropriate. All modules should have a short description.\n").
			WithObject(
				dag.TypeDef().WithObject("Registryauth", dagger.TypeDefWithObjectOpts{Description: "Registryauth is a Dagger module.\n\nThis module is used to create and manage containers."}).
					WithFunction(
						dag.Function("Base",
							dag.TypeDef().WithObject("Registryauth")).
							WithDescription("Base sets the base image and version, and creates the base container.\n\nThe default image is \"alpine/latest\" and the default version is \"latest\".").
							WithArg("imageURL", dag.TypeDef().WithKind(dagger.StringKind))).
					WithFunction(
						dag.Function("WithEnvironmentVariable",
							dag.TypeDef().WithObject("Registryauth")).
							WithDescription("WithEnvironmentVariable sets an environment variable in the container.\n\nParameters:\n  - name: The name of the environment variable (e.g., \"HOST\").\n  - value: The value of the environment variable (e.g., \"localhost\").\n  - expand: Whether to replace `${VAR}` or $VAR in the value according to the current\n    environment variables defined in the container (e.g., \"/opt/bin:$PATH\").\n    Optional parameter.").
							WithArg("name", dag.TypeDef().WithKind(dagger.StringKind), dagger.FunctionWithArgOpts{Description: "name is the name of the environment variable."}).
							WithArg("value", dag.TypeDef().WithKind(dagger.StringKind), dagger.FunctionWithArgOpts{Description: "value is the value of the environment variable."}).
							WithArg("expand", dag.TypeDef().WithKind(dagger.BooleanKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "expand is whether to replace `${VAR}` or $VAR in the value according to the current"})).
					WithFunction(
						dag.Function("WithContainer",
							dag.TypeDef().WithObject("Registryauth")).
							WithDescription("WithContainer sets the container to be used.\n\nParameters:\n- ctr: The container to run the command in. If passed, it will override the container set in the Dagger instance.").
							WithArg("ctr", dag.TypeDef().WithObject("Container"))).
					WithFunction(
						dag.Function("WithFileMountedInContainer",
							dag.TypeDef().WithObject("Registryauth")).
							WithDescription("WithFileMountedInContainer adds a file to the container.\n\nParameters:\n- file: The file to add to the container.\n- dest: The destination path in the container. Optional parameter.\n- owner: The owner of the file. Optional parameter.").
							WithArg("file", dag.TypeDef().WithObject("File")).
							WithArg("dest", dag.TypeDef().WithKind(dagger.StringKind)).
							WithArg("owner", dag.TypeDef().WithKind(dagger.StringKind))).
					WithFunction(
						dag.Function("WithCacheBuster",
							dag.TypeDef().WithObject("Registryauth")).
							WithDescription("WithCacheBuster sets a cache-busting environment variable in the container.\n\nThis method sets an environment variable \"CACHE_BUSTER\" with a timestamp value in RFC3339Nano format.\nThis can be useful for invalidating caches by providing a unique value.\n\nReturns:\n  - *Registryauth: The updated Registryauth with the cache-busting environment variable set.")).
					WithFunction(
						dag.Function("OpenTerminal",
							dag.TypeDef().WithObject("Container")).
							WithDescription("OpenTerminal returns a terminal\n\nIt returns a terminal for the container.\nArguments:\n- None.\nReturns:\n- *Terminal: The terminal for the container.")).
					WithFunction(
						dag.Function("RunShell",
							dag.TypeDef().WithKind(dagger.StringKind)).
							WithDescription("RunShell runs a shell command in the container.\n\nIt runs a shell command in the container and returns the output.\nArguments:\n- cmd: The command to run in the container.\nReturns:\n- string: The output of the command.\n- error: An error if the command fails.").
							WithArg("cmd", dag.TypeDef().WithKind(dagger.StringKind))).
					WithFunction(
						dag.Function("PrintEnvVars",
							dag.TypeDef().WithKind(dagger.StringKind)).
							WithDescription("PrintEnvVars retrieves and prints the environment variables of the container.\n\nIt executes the `printenv` command inside the container to get a list of all\nenvironment variables and their respective values.\n\nArguments:\n- None.\n\nReturns:\n  - string: A string containing all environment variables in the format\n    \"KEY=VALUE\", separated by newlines.\n  - error: An error if the command fails, wrapped with additional context.\n\nUsage example:\n```go\nenvVars, err := RegistryauthInstance.PrintEnvVars()\n\n\tif err != nil {\n\t    log.Fatalf(\"Error retrieving environment variables: %v\", err)\n\t}\n\nfmt.Println(envVars).")).
					WithFunction(
						dag.Function("BaseAlpine",
							dag.TypeDef().WithObject("Registryauth")).
							WithDescription("BaseAlpine sets the base image to an Alpine Linux image and creates the base container.\n\nParameters:\n- version: The version of the Alpine image to use. Optional parameter. Defaults to \"latest\".\n\nReturns a pointer to the Registryauth instance.").
							WithArg("version", dag.TypeDef().WithKind(dagger.StringKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "version is the version of the Alpine image to use, e.g., \"3.17.3\"."})).
					WithFunction(
						dag.Function("BaseUbuntu",
							dag.TypeDef().WithObject("Registryauth")).
							WithDescription("BaseUbuntu sets the base image to an Ubuntu Linux image and creates the base container.\n\nParameters:\n- version: The version of the Ubuntu image to use. Optional parameter. Defaults to \"latest\".\n\nReturns a pointer to the Registryauth instance.").
							WithArg("version", dag.TypeDef().WithKind(dagger.StringKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "version is the version of the Ubuntu image to use, e.g., \"22.04\"."})).
					WithFunction(
						dag.Function("BaseBusyBox",
							dag.TypeDef().WithObject("Registryauth")).
							WithDescription("BaseBusyBox sets the base image to a BusyBox Linux image and creates the base container.\n\nParameters:\n- version: The version of the BusyBox image to use. Optional parameter. Defaults to \"latest\".\n\nReturns a pointer to the Registryauth instance.").
							WithArg("version", dag.TypeDef().WithKind(dagger.StringKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "version is the version of the BusyBox image to use, e.g., \"1.35.0\"."})).
					WithFunction(
						dag.Function("BaseWolfi",
							dag.TypeDef().WithObject("Registryauth")).
							WithDescription("BaseWolfi sets the base image to a Wolfi Linux image and creates the base container.\n\nParameters:\n- version: The version of the Wolfi image to use. Optional parameter. Defaults to \"latest\".\n- packages: Additional packages to install. Optional parameter.\n- overlays: Overlay images to merge on top of the base. Optional parameter.\n\nReturns a pointer to the Registryauth instance.").
							WithArg("version", dag.TypeDef().WithKind(dagger.StringKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "version is the version of the Wolfi image to use, e.g., \"latest\"."}).
							WithArg("packages", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(dagger.StringKind)).WithOptional(true), dagger.FunctionWithArgOpts{Description: "packages is the list of additional packages to install."}).
							WithArg("overlays", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("Container")).WithOptional(true), dagger.FunctionWithArgOpts{Description: "overlays are images to merge on top of the base.\nSee https://twitter.com/ibuildthecloud/status/1721306361999597884"})).
					WithField("Ctr", dag.TypeDef().WithObject("Container"), dagger.TypeDefWithFieldOpts{Description: "Ctr is the container to use as a base container."}).
					WithConstructor(
						dag.Function("New",
							dag.TypeDef().WithObject("Registryauth")).
							WithDescription("New creates a new Registryauth module.\n\nParameters:\n- version: The version of the GoReleaser to use, e.g., \"v1.22.0\". Optional parameter.\n- image: The image to use as the base container. Optional parameter.\n- ctr: The container to use as a base container. Optional parameter.\n- envVarsFromHost: A list of environment variables to pass from the host to the container in a\nslice of strings. Optional parameter.\n\nReturns a pointer to a Registryauth instance and an error, if any.").
							WithArg("version", dag.TypeDef().WithKind(dagger.StringKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "version is the version of the container image to use."}).
							WithArg("image", dag.TypeDef().WithKind(dagger.StringKind).WithOptional(true), dagger.FunctionWithArgOpts{Description: "image is the container image to use."}).
							WithArg("ctr", dag.TypeDef().WithObject("Container").WithOptional(true), dagger.FunctionWithArgOpts{Description: "ctr is the container to use as a base container."}).
							WithArg("envVarsFromHost", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(dagger.StringKind)).WithOptional(true), dagger.FunctionWithArgOpts{Description: "envVarsFromHost is a list of environment variables to pass from the host to the container in a slice of strings."}))), nil
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
