// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/Excoriate/daggerverse/registryauth/tests/internal/dagger"
	"github.com/Excoriate/daggerverse/registryauth/tests/internal/querybuilder"
	"github.com/Excoriate/daggerverse/registryauth/tests/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Tests) MarshalJSON() ([]byte, error) {
	var concrete struct {
		TestDir *dagger.Directory
	}
	concrete.TestDir = r.TestDir
	return json.Marshal(&concrete)
}

func (r *Tests) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		TestDir *dagger.Directory
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.TestDir = concrete.TestDir
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
}

func dispatch(ctx context.Context) error {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return fmt.Errorf("invoke: %w", err)
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}
	if err = fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Tests":
		switch fnName {
		case "TestWithNewNetrcFileGitHub":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithNewNetrcFileGitHub(&parent, ctx)
		case "TestWithNewNetrcFileAsSecretGitHub":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithNewNetrcFileAsSecretGitHub(&parent, ctx)
		case "TestWithNewNetrcFileGitLab":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithNewNetrcFileGitLab(&parent, ctx)
		case "TestWithNewNetrcFileAsSecretGitLab":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithNewNetrcFileAsSecretGitLab(&parent, ctx)
		case "TestGoWithGoPlatform":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithGoPlatform(&parent, ctx)
		case "TestGoWithCgoEnabled":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithCgoEnabled(&parent, ctx)
		case "TestGoWithCgoDisabled":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithCgoDisabled(&parent, ctx)
		case "TestGoWithGoBuildCache":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithGoBuildCache(&parent, ctx)
		case "TestGoWithGoModCache":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithGoModCache(&parent, ctx)
		case "TestGoWithGoInstall":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithGoInstall(&parent, ctx)
		case "TestGoWithGoExec":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithGoExec(&parent, ctx)
		case "TestGoWithGoBuild":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithGoBuild(&parent, ctx)
		case "TestGoWithGoPrivate":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithGoPrivate(&parent, ctx)
		case "TestGoWithGCCCompiler":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithGCCCompiler(&parent, ctx)
		case "TestGoWithGoTestSum":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithGoTestSum(&parent, ctx)
		case "TestGoWithGoReleaserAndGolangCILint":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithGoReleaserAndGolangCILint(&parent, ctx)
		case "TestDaggerWithDaggerCLI":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestDaggerWithDaggerCLI(&parent, ctx)
		case "TestDaggerSetupDaggerInDagger":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestDaggerSetupDaggerInDagger(&parent, ctx)
		case "TestContainerWithUbuntuBase":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestContainerWithUbuntuBase(&parent, ctx)
		case "TestContainerWithAlpineBase":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestContainerWithAlpineBase(&parent, ctx)
		case "TestContainerWithBusyBoxBase":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestContainerWithBusyBoxBase(&parent, ctx)
		case "TestContainerWithWolfiBase":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestContainerWithWolfiBase(&parent, ctx)
		case "TestWithContainer":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithContainer(&parent, ctx)
		case "TestTerminal":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Tests).TestTerminal(&parent), nil
		case "TestPassingEnvVarsInConstructor":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestPassingEnvVarsInConstructor(&parent, ctx)
		case "TestWithEnvironmentVariable":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithEnvironmentVariable(&parent, ctx)
		case "TestWithSource":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithSource(&parent, ctx)
		case "TestWithSecretAsEnvVar":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithSecretAsEnvVar(&parent, ctx)
		case "TestWithDownloadedFile":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithDownloadedFile(&parent, ctx)
		case "TestWithClonedGitRepo":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithClonedGitRepo(&parent, ctx)
		case "TestWithCacheBuster":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithCacheBuster(&parent, ctx)
		case "TestWithUtilitiesInAlpineContainer":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithUtilitiesInAlpineContainer(&parent, ctx)
		case "TestWithUtilitiesInUbuntuContainer":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithUtilitiesInUbuntuContainer(&parent, ctx)
		case "TestWithGitInAlpineContainer":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithGitInAlpineContainer(&parent, ctx)
		case "TestWithGitInUbuntuContainer":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestWithGitInUbuntuContainer(&parent, ctx)
		case "TestIACWithTerragruntAlpine":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestIACWithTerragruntAlpine(&parent, ctx)
		case "TestIACWithTerragruntUbuntu":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestIACWithTerragruntUbuntu(&parent, ctx)
		case "TestAll":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestAll(&parent, ctx)
		case "TestRunShellCMD":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestRunShellCMD(&parent, ctx)
		case "TestPrintEnvVars":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestPrintEnvVars(&parent, ctx)
		case "TestInspectEnvVar":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestInspectEnvVar(&parent, ctx)
		case "TestCloneGitRepo":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestCloneGitRepo(&parent, ctx)
		case "TestDownloadFile":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestDownloadFile(&parent, ctx)
		case "TestHTTPCurl":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestHTTPCurl(&parent, ctx)
		case "TestHTTPDoJSONAPICall":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestHTTPDoJSONAPICall(&parent, ctx)
		case "TestIACWithTerraformAlpine":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestIACWithTerraformAlpine(&parent, ctx)
		case "TestIACWithTerraformUbuntu":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestIACWithTerraformUbuntu(&parent, ctx)
		case "TestGoWithGoServerSimple":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithGoServerSimple(&parent, ctx)
		case "TestGoWithGoServerAdvanced":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*Tests).TestGoWithGoServerAdvanced(&parent, ctx)
		case "":
			var parent Tests
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return New(), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "":
		return dag.Module().
			WithDescription("A generated module for test the Registryauth functions\n\nThis module has been generated via dagger init and serves as a reference to\nbasic module structure as you get started with Dagger.\n\nTwo functions have been pre-created. You can modify, delete, or add to them,\nas needed. They demonstrate usage of arguments and return types using simple\necho and grep commands. The functions can be called from the dagger CLI or\nfrom one of the SDKs.\n\nThe first line in this comment block is a short description line and the\nrest is a long description with more detail on the module's purpose or usage,\nif appropriate. All modules should have a short description.\n").
			WithObject(
				dag.TypeDef().WithObject("Tests", dagger.TypeDefWithObjectOpts{Description: "Tests is a collection of tests.\n\nIt's a struct that contains a single field, TestDir, which is a pointer to a Directory."}).
					WithFunction(
						dag.Function("TestWithNewNetrcFileGitHub",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithNewNetrcFileGitHub tests the creation of a new .netrc file with GitHub credentials.\n\nThis function verifies that the GitHub credentials are set correctly in the .netrc file using a secret.\nIt creates a new secret with the GitHub credentials and sets them in the target module's .netrc file.\nThe function then reads the .netrc file from the container and checks if it contains the expected machine entry.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if the creation of the .netrc file fails, if the file's content does\n    not match the expected result,\n    or if there is an issue with executing commands in the container.")).
					WithFunction(
						dag.Function("TestWithNewNetrcFileAsSecretGitHub",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithNewNetrcFileAsSecretGitHub tests the creation of a new .netrc file with GitHub credentials.\n\nThis function verifies that the GitHub credentials are set correctly in the .netrc file using a secret.\nIt creates a new secret with the GitHub credentials and sets them in the target module's .netrc file.\nThe function then reads the .netrc file from the container and checks if it contains the expected machine entry.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if the creation of the .netrc file fails, if the file's\n    content does not match the expected result,\n    or if there is an issue with executing commands in the container.")).
					WithFunction(
						dag.Function("TestWithNewNetrcFileGitLab",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithNewNetrcFileGitLab tests the creation of a new .netrc file with GitLab credentials.\n\nThis function verifies that the GitLab credentials are set correctly in the .netrc file using a secret.\nIt creates a new secret with the GitLab credentials and sets them in the target module's .netrc file.\nThe function then reads the .netrc file from the container and checks if it contains the expected machine entry.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if the creation of the .netrc file fails, if the file's\n    content does not match the expected result,\n    or if there is an issue with executing commands in the container.")).
					WithFunction(
						dag.Function("TestWithNewNetrcFileAsSecretGitLab",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithNewNetrcFileAsSecretGitLab creates a new .netrc file with GitLab credentials.\n\nThis method verifies that the GitLab credentials are set correctly in the .netrc file using a secret.\nIt creates a new secret with the GitLab credentials and sets them in the target module's .netrc file.\nThe method then reads the .netrc file from the container and checks if it contains the expected machine entry.\n\nArguments:\n- ctx (context.Context): The context for the method execution.\n\nReturns:\n  - error: Returns an error if the creation of the .netrc file fails, if the file's\n    content does not match the expected result,\n    or if there is an issue with executing commands in the container.")).
					WithFunction(
						dag.Function("TestGoWithGoPlatform",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithGoPlatform tests the setting of different Go platforms within the target module's container.\n\nThis method creates a target module with a Golang Alpine container and sets different Go platforms.\nIt verifies if the Go platform is correctly set by running the `go version` command within the container\nfor each defined platform.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if there is an issue setting the Go platform, executing\n    commands in the container, or if the `go version` output does not match the expected pattern.")).
					WithFunction(
						dag.Function("TestGoWithCgoEnabled",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithCgoEnabled tests enabling CGO in a Go Alpine container.\n\nThis function performs the following steps:\n1. Sets up the Go Alpine container.\n2. Enables the CGO feature in the Go environment.\n3. Verifies that the CGO_ENABLED environment variable is set to \"1\".\n\nParameters:\n- ctx: The context to control the execution.\n\nReturns:\n- error: If any step fails or produces an unexpected output, an error is returned.")).
					WithFunction(
						dag.Function("TestGoWithCgoDisabled",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithCgoDisabled tests disabling CGO in a Go Alpine container.\n\nThis function performs the following steps:\n1. Sets up the Go Alpine container.\n2. Disables the CGO feature in the Go environment.\n3. Verifies that the CGO_ENABLED environment variable is set to \"0\".\n\nParameters:\n- ctx: The context to control the execution.\n\nReturns:\n- error: If any step fails or produces an unexpected output, an error is returned.")).
					WithFunction(
						dag.Function("TestGoWithGoBuildCache",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithGoBuildCache verifies that the Go build cache (GOCACHE) is set correctly\nin the provided Alpine container.\n\nThis function performs the following steps:\n1. Sets up the Go Alpine container without specifying a particular Go version.\n2. Configures the Go build cache.\n3. Executes the `go env GOCACHE` command to retrieve the GOCACHE environment variable.\n4. Validates that the GOCACHE environment variable is set to the expected path.\n\nParameters:\n- ctx: The context to control the execution.\n\nReturns:\n- error: If any of the steps fail, an error is returned indicating what went wrong.")).
					WithFunction(
						dag.Function("TestGoWithGoModCache",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithGoModCache verifies that the Go module cache (GOMODCACHE) is set correctly\nin the provided Alpine container.\n\nThis function performs the following steps:\n1. Sets up the Go Alpine container without specifying a particular Go version.\n2. Configures the Go module cache.\n3. Executes the `go env GOMODCACHE` command to retrieve the GOMODCACHE environment variable.\n4. Validates that the GOMODCACHE environment variable is set to the expected path.\n\nParameters:\n- ctx: The context to control the execution.\n\nReturns:\n- error: If any of the steps fail, an error is returned indicating what went wrong.")).
					WithFunction(
						dag.Function("TestGoWithGoInstall",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithGoInstall tests the installation of various Go packages\nin the provided Alpine container.\n\nThis function performs the following steps:\n1. Sets up the Go Alpine container with the expected Go version.\n2. Installs a list of specified Go packages.\n3. Verifies the installation by checking if the installed packages are in the PATH.\n4. Ensures the Go module cache is correctly set.\n\nParameters:\n- ctx: The context to control the execution.\n\nReturns:\n- error: If any of the installation or verification steps fail, an error is returned.\n\nlonger function.")).
					WithFunction(
						dag.Function("TestGoWithGoExec",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithGoExec tests the execution of various Go commands and ensures they produce the expected\nresults in the provided Alpine container.\n\nThis function performs the following steps:\n1. Sets up the Go Alpine container with the expected Go version.\n2. Executes the `go version` command and verifies the output against the expected Go version.\n3. Runs additional Go commands (e.g., `go env GOPATH`) and checks their\noutput against expected values.\n4. Verifies specific Go environment variables (e.g., `GOPROXY`) to ensure\nthey are set correctly.\n\nParameters:\n- ctx: The context to control the execution.\n\nReturns:\n- error: If any of the commands fail or produce unexpected output, an error is returned.")).
					WithFunction(
						dag.Function("TestGoWithGoBuild",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithGoBuild tests the Go build process using the provided Alpine container.\n\nThis function performs the following steps:\n\n1. Sets up the Go Alpine container with the expected Go version.\n2. Configures the build process with specific options including the source\ndirectory, target platform, package to build, and output binary name.\n3. Executes the build process and checks for errors.\n4. Verifies the presence of the output binary in the container's directory.\n5. Runs the binary and verifies the output against the expected string.\n\nParameters:\n- ctx: The context to control the execution.")).
					WithFunction(
						dag.Function("TestGoWithGoPrivate",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithGoPrivate tests the configuration of the GOPRIVATE environment variable\nusing the WithGoPrivate method. It ensures that the GOPRIVATE environment variable\nis set correctly within the specified context.\n\nThis function performs the following steps:\n1. Sets up the Go module container using the default module template.\n2. Configures the GOPRIVATE environment variable to the specified value.\n3. Executes the `go env GOPRIVATE` command to retrieve the GOPRIVATE environment variable.\n4. Validates that the GOPRIVATE environment variable is set to the expected value.\n\nParameters:\n- ctx: The context to control the execution.\n\nReturns:\n- error: If any of the steps fail, an error is returned indicating what went wrong.")).
					WithFunction(
						dag.Function("TestGoWithGCCCompiler",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithGCCCompiler verifies the installation and presence of the GCC compiler\nwithin the specified context, using the provided Alpine container setup.\n\nThis function performs the following steps:\n1. Sets up the Go module container using the default module template.\n2. Installs the GCC compiler and associated development tools.\n3. Executes the `gcc --version` command to verify the GCC compiler installation.\n4. Validates the output to confirm the presence of the GCC compiler.\n\nParameters:\n- ctx: The context to control the execution.\n\nReturns:\n  - error: If any of the installation or verification steps fail, an error is returned\n    indicating what went wrong.")).
					WithFunction(
						dag.Function("TestGoWithGoTestSum",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithGoTestSum verifies the installation and presence of the GoTestSum tool\nwithin the specified context, using the provided Alpine container setup.\n\nThis function performs the following steps:\n1. Sets up the Go module container using the default module template.\n2. Installs the GoTestSum tool and its dependency `tparse` in the container.\n3. Executes the `gotestsum --version` command to verify the GoTestSum tool installation.\n4. Validates the output to confirm the presence of the GoTestSum tool.\n\nParameters:\n- ctx: The context to control the execution.\n\nReturns:\n  - error: If any of the installation or verification steps fail, an error is returned\n    indicating what went wrong.\n\nTestGoWithGoTestSum verifies the installation and presence of the GoTestSum tool\nwithin the specified context, using the provided Alpine container setup.")).
					WithFunction(
						dag.Function("TestGoWithGoReleaserAndGolangCILint",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithGoReleaserAndGolangCILint tests the installation and setup\nof GoReleaser and GoLangCILint using gotoolbox.\n\nThis function sets up the Go toolbox with a specified Go version, installs\nGoReleaser and GoLangCILint, and verifies their installation.\n\nctx: The context for the test execution, to control cancellation and deadlines.\n\nReturns an error if the installation or verification of GoReleaser or GoLangCILint fails.")).
					WithFunction(
						dag.Function("TestDaggerWithDaggerCLI",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestDaggerWithDaggerCLI tests various versions of the Dagger CLI from v0.12.0 to v0.12.4\n\nThis function uses the provided context to run a series of tests that validate the Dagger CLI.\nIt verifies that the CLI version reported matches the expected version for each specific version tested.\n\nctx: The context for managing timeout and cancelation.\nReturns an error if any of the tests fail.\n\nUsage:\nerr := m.TestDaggerWithDaggerCLI(ctx)\n\n\tif err != nil {\n\t  log.Fatalf(\"Test failed with error: %v\", err)\n\t}")).
					WithFunction(
						dag.Function("TestDaggerSetupDaggerInDagger",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestDaggerSetupDaggerInDagger tests the setup of Dagger within another Dagger environment.\n\nThis function performs a series of actions to ensure that Dagger can be correctly installed and run\ninside a container that is managed by another instance of Dagger. It checks the installation of the Dagger CLI,\nthe Docker service, and the initialization of a Dagger module.\n\nctx: The context for managing timeout and cancellation.\nReturns an error if any of the setup checks fail.\n\nUsage:\nerr := m.TestDaggerSetupDaggerInDagger(ctx)\n\n\tif err != nil {\n\t  log.Fatalf(\"Test failed with error: %v\", err)\n\t}")).
					WithFunction(
						dag.Function("TestContainerWithUbuntuBase",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestContainerWithUbuntuBase tests that the target module is based on the Ubuntu 22.04 image.\n\nThis function verifies that the target module is configured appropriately to use the base Ubuntu 22.04 image.\nIt runs a command to get the OS version and confirms it matches \"Ubuntu 22.04\".\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if the Ubuntu image is not used or if the output is not as expected.")).
					WithFunction(
						dag.Function("TestContainerWithAlpineBase",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestContainerWithAlpineBase tests that the target module is based on the Alpine Linux v3.17.3 image.\n\nThis function verifies that the target module is configured appropriately to use the base Alpine Linux v3.17.3 image.\nIt runs a command to get the OS version and confirms it matches \"Alpine Linux v3.17.3\".\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if the Alpine image is not used or if the output is not as expected.")).
					WithFunction(
						dag.Function("TestContainerWithBusyBoxBase",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestContainerWithBusyBoxBase tests that the target module is based on the BusyBox v1.35.0 image.\n\nThis function verifies that the target module is configured appropriately to use the base BusyBox v1.35.0 image.\nIt runs a command to get the OS version and confirms it matches \"BusyBox v1.35.0\".\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if the BusyBox image is not used or if the output is not as expected.")).
					WithFunction(
						dag.Function("TestContainerWithWolfiBase",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestContainerWithWolfiBase tests that the target module is based on the Wolfi image.\n\nThis function verifies that the target module is configured appropriately to use the base Wolfi image.\nIt runs a command to get the OS version and confirms it matches \"Wolfi\".\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if the Wolfi image is not used or if the output is not as expected.")).
					WithFunction(
						dag.Function("TestWithContainer",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithContainer tests if the container is set correctly.\n\nThis API is used to override the container set in the Dagger instance.")).
					WithFunction(
						dag.Function("TestTerminal",
							dag.TypeDef().WithObject("Container")).
							WithDescription("TestTerminal returns a terminal for testing.\n\nThis is a helper method for tests, in order to get a terminal for testing purposes.")).
					WithFunction(
						dag.Function("TestPassingEnvVarsInConstructor",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestPassingEnvVarsInConstructor tests if the environment variables are passed correctly in the constructor.\n\nThis is a helper method for tests, in order to test if the env vars are passed correctly in the constructor.")).
					WithFunction(
						dag.Function("TestWithEnvironmentVariable",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithEnvironmentVariable tests if the environment variables are passed correctly in the API.\n\nThis is a helper method for tests, in order to test if the env vars are passed correctly in the API.")).
					WithFunction(
						dag.Function("TestWithSource",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithSource tests if the source directory is set correctly.")).
					WithFunction(
						dag.Function("TestWithSecretAsEnvVar",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithSecretAsEnvVar tests the setting of environment variables using secrets.\n\nThis method verifies that environment variables are correctly set in the container using secrets.\nIt creates secrets for AWS, GCP, and another example, then sets these secrets as environment variables\nin the target module's container. The method runs the `printenv` command within the container and checks\nif the output contains the expected environment variables.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if there is an issue creating secrets, setting environment variables,\n    executing commands in the container, or if the output does not contain the expected environment variables.")).
					WithFunction(
						dag.Function("TestWithDownloadedFile",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithDownloadedFile tests the downloading of a file from a URL.\n\nThis method verifies that a file can be downloaded from a URL and mounted in the container.\nIt downloads a file from a URL, mounts it in the container, and checks if the file exists.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if there is an issue downloading the file, mounting it in the container,\n    or if the file is not found.")).
					WithFunction(
						dag.Function("TestWithClonedGitRepo",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithClonedGitRepo tests the WithClonedGitRepo function.")).
					WithFunction(
						dag.Function("TestWithCacheBuster",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithCacheBuster tests the setting of a cache-busting environment variable\nwithin the target module's container.\n\nThis method sets a cache-busting environment variable (`CACHE_BUSTER`) in\nthe target module's container and verifies if it is correctly set by running\nthe `printenv` command within the container.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if there is an issue setting the environment variable,\n    executing commands in the container, or if the `CACHE_BUSTER` environment variable\n    is not found in the output.")).
					WithFunction(
						dag.Function("TestWithUtilitiesInAlpineContainer",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithUtilitiesInAlpineContainer tests if the Alpine container with utilities is set correctly.\n\nThis method verifies that the Alpine container includes specific utilities by running a command within the container.\nThe test checks if the 'curl' utility is available and functioning as expected.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n- error: Returns an error if the utility check fails or the output does not contain the expected results.")).
					WithFunction(
						dag.Function("TestWithUtilitiesInUbuntuContainer",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithUtilitiesInUbuntuContainer tests if the Alpine container with utilities is set correctly.\n\nThis method verifies that the Alpine container includes specific utilities by running a command within the container.\nThe test checks if the 'curl' utility is available and functioning as expected.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n- error: Returns an error if the utility check fails or the output does not contain the expected results.")).
					WithFunction(
						dag.Function("TestWithGitInAlpineContainer",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithGitInAlpineContainer tests the presence of the Git version control system\nwithin an Alpine-based container.\n\nThis method configures the target module to include Git within an Alpine container,\nexecutes a command to check the Git version, and verifies the output.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if there is an issue configuring the container,\n    executing the command, or if the output does not contain the expected Git version information.")).
					WithFunction(
						dag.Function("TestWithGitInUbuntuContainer",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestWithGitInUbuntuContainer verifies that the 'git' command is available\nin the target module's container which uses an Ubuntu base image.\n\nThis method reconfigures the target module to include 'git' in an Ubuntu container,\nexecutes the 'git --version' command within the container to confirm its presence,\nand checks the output to ensure 'git' is correctly installed.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if there is an issue configuring the container,\n    executing the 'git' command, or if the 'git' command is not found in the output.")).
					WithFunction(
						dag.Function("TestIACWithTerragruntAlpine",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestIACWithTerragruntAlpine tests Terragrunt installation on Alpine.")).
					WithFunction(
						dag.Function("TestIACWithTerragruntUbuntu",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestIACWithTerragruntUbuntu tests Terragrunt installation on Ubuntu.")).
					WithFunction(
						dag.Function("TestAll",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestAll executes all tests.\n\nThis is a helper method for tests, in order to execute all tests.")).
					WithFunction(
						dag.Function("TestRunShellCMD",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestRunShellCMD runs a shell command in the container.\n\nTests if the shell command is executed correctly in the container.")).
					WithFunction(
						dag.Function("TestPrintEnvVars",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestPrintEnvVars tests the PrintEnvVars function.\n\nThis method verifies that environment variables can be printed within the context\nof the target module's execution. It runs the `printenv` command within the container\nand checks if any environment variables are present.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if there is an issue printing environment variables,\n    or if no environment variables are found in the output.")).
					WithFunction(
						dag.Function("TestInspectEnvVar",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestInspectEnvVar tests the inspection of an environment variable set in the container.\n\nThis method verifies that an environment variable is correctly set in the target module's container.\nIt sets an environment variable and then inspects it to check if the value matches the expected result.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if there is an issue setting the environment variable, inspecting the variable,\n    or if the inspected value does not match the expected result.")).
					WithFunction(
						dag.Function("TestCloneGitRepo",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestCloneGitRepo tests the CloneGitRepo function.")).
					WithFunction(
						dag.Function("TestDownloadFile",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestDownloadFile tests the downloading of a file from a URL and mounts it in the container.\n\nThis method verifies that a file can be downloaded from a URL, mounted\nin the container, and checks if the file exists.\n\nArguments:\n- ctx (context.Context): The context for the test execution.\n\nReturns:\n  - error: Returns an error if there is an issue downloading the file, mounting it in the container,\n    or if the file is not found in the mounted path.")).
					WithFunction(
						dag.Function("TestHTTPCurl",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestHTTPCurl tests an HTTP GET request using the curl command within an Alpine container.\n\nThis function performs the following steps:\n1. Sets up the Alpine container with necessary utilities to perform the curl operation.\n2. Executes the curl command against the specified target URL and captures the output.\n3. Verifies that the curl command produced non-empty output.\n4. Checks for errors during the curl command execution.\n\nParameters:\n- ctx: The context to control the execution.\n\nReturns:\n- error: If the curl command fails or produces an empty output, an error is returned.")).
					WithFunction(
						dag.Function("TestHTTPDoJSONAPICall",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestHTTPDoJSONAPICall tests an HTTP GET request to fetch product information from a JSON API.\n\nThis function performs the following steps:\n1. Sends an HTTP GET request to the specified URL to fetch product information in JSON format.\n2. Checks if the response is non-nil.\n3. Reads the contents of the JSON response file.\n4. Verifies that the content is not empty and that it does not contain an error message.\n5. Unmarshals the JSON response into a slice of ProductJSONApiTest structs.\n6. Ensures that the unmarshalling was successful and the response contains at least one product.\n\nParameters:\n- ctx: The context to control the execution.\n\nReturns:\n- error: If any of the steps fail, an error is returned.")).
					WithFunction(
						dag.Function("TestIACWithTerraformAlpine",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestIACWithTerraformAlpine checks the installation, PATH inclusion, and functionality of Terraform\non an Alpine Linux environment across various Terraform versions.\n\nIt verifies Terraform installation by running `terraform version`, ensures\nTerraform is in the system PATH by using `which terraform`, and tests that\nTerraform commands work correctly by running `terraform --help`.\n\nArgs:\n\n\tctx: Context to control execution.\n\tversion: List of Terraform versions to test. An empty string implies the latest version.\n\nReturns:\n\n\tAn error if any of the Terraform checks fail for any version; otherwise, nil.")).
					WithFunction(
						dag.Function("TestIACWithTerraformUbuntu",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestIACWithTerraformUbuntu checks the installation, PATH inclusion, and functionality of Terraform\non an Ubuntu Linux environment across various Terraform versions.\n\nIt verifies Terraform installation by running `terraform version`, ensures Terraform is in\nthe system PATH by using `which terraform`, and tests that Terraform commands work correctly\nby running `terraform --help`.\n\nArgs:\n\n\tctx: Context to control execution.\n\tversion: List of Terraform versions to test. An empty string implies the latest version.\n\nReturns:\n\n\tAn error if any of the Terraform checks fail for any version; otherwise, nil.")).
					WithFunction(
						dag.Function("TestGoWithGoServerSimple",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithGoServerSimple is an end-to-end integration test for running a Go server\nand testing its API endpoint.\n\nThis function sets up and starts a Go server using the Gotoolbox,\nthen initializes a client container to send an HTTP request to the server.\n\nctx: The context for the test execution, to control cancellation and deadlines.\n\nReturns an error if starting the server or fetching the API response fails.")).
					WithFunction(
						dag.Function("TestGoWithGoServerAdvanced",
							dag.TypeDef().WithKind(dagger.VoidKind).WithOptional(true)).
							WithDescription("TestGoWithGoServerAdvanced is a comprehensive end-to-end integration test for running a Go server\nwith advanced configuration options and testing its API endpoint.\n\nThe function sets up and starts a Go server using the Gotoolbox, then configures advanced settings\nsuch as debugging, HTTP configuration, DNS resolver, and garbage collection settings.\n\nA client container is initialized to send an HTTP request to the server's API endpoint, and the response\nis verified for expected content.\n\nParameters:\n  - ctx: Context for the test execution, used to control cancellation and deadlines.\n\nReturns:\n  - An error if starting the server, configuring it, or fetching the API response fails.")).
					WithField("TestDir", dag.TypeDef().WithObject("Directory")).
					WithConstructor(
						dag.Function("New",
							dag.TypeDef().WithObject("Tests")).
							WithDescription("New creates a new Tests instance.\n\nIt's the initial constructor for the Tests struct."))), nil
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
